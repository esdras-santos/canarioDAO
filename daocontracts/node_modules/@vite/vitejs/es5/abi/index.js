"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAbiByType = exports.decodeLog = exports.decodeParameters = exports.encodeParameters = exports.decodeParameter = exports.encodeParameter = exports.encodeFunctionCall = exports.encodeFunctionSignature = exports.encodeLogSignature = void 0;
var vitejs_utils_1 = require("./../utils");
var encodeFunction_1 = require("./encodeFunction");
var coder_1 = require("./coder");
var inputsType_1 = require("./inputsType");
function encodeLogSignature(jsonFunction, methodName) {
    return encodeFunction_1.encodeFunction(jsonFunction, methodName);
}
exports.encodeLogSignature = encodeLogSignature;
function encodeFunctionSignature(jsonFunction, methodName) {
    var result = encodeFunction_1.encodeFunction(jsonFunction, methodName);
    return result.slice(0, 8);
}
exports.encodeFunctionSignature = encodeFunctionSignature;
function encodeFunctionCall(jsonInterface, params, methodName) {
    return encodeFunctionSignature(jsonInterface, methodName) + encodeParameters(jsonInterface, params, methodName);
}
exports.encodeFunctionCall = encodeFunctionCall;
function encodeParameter(type, param) {
    return coder_1.encodeParameter(type, param).result;
}
exports.encodeParameter = encodeParameter;
exports.decodeParameter = coder_1.decodeParameter;
function encodeParameters(types, params, methodName) {
    try {
        if (methodName || !vitejs_utils_1.isArray(types) && vitejs_utils_1.isObject(types)) {
            var func = encodeFunction_1.getFunction(types, methodName);
            types = inputsType_1.getTypes(func);
        }
    }
    catch (err) {
    }
    return coder_1.encodeParameters(inputsType_1.getTypes(types), params);
}
exports.encodeParameters = encodeParameters;
function decodeParameters(types, params, methodName) {
    try {
        if (methodName || !vitejs_utils_1.isArray(types) && vitejs_utils_1.isObject(types)) {
            var func = encodeFunction_1.getFunction(types, methodName);
            types = inputsType_1.getTypes(func);
        }
    }
    catch (err) {
    }
    return coder_1.decodeParameters(inputsType_1.getTypes(types), params);
}
exports.decodeParameters = decodeParameters;
function decodeLog(abi, data, topics, methodName) {
    if (data === void 0) { data = ''; }
    var nonIndexedInputs = [];
    var nonIndexedTypes = [];
    var inputs = getInputs(abi, methodName);
    var returnValues = {};
    var topicIndex = abi.anonymous ? 0 : 1;
    inputs.forEach(function (input, i) {
        if (input.indexed) {
            var param = (['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {
                return input.type.indexOf(staticType) !== -1;
            })) ? exports.decodeParameter(input.type, topics[topicIndex]) : topics[topicIndex];
            topicIndex++;
            returnValues[i] = param;
            if (input.name)
                returnValues[input.name] = param;
        }
        else {
            nonIndexedInputs.push(input);
            nonIndexedTypes.push(input.type);
        }
    });
    var nonIndexedParams = decodeParameters(nonIndexedTypes, data);
    var index = 0;
    inputs.forEach(function (input, i) {
        if (!input.indexed) {
            returnValues[i] = nonIndexedParams[index];
            if (input.name)
                returnValues[input.name] = nonIndexedParams[index];
            index++;
        }
    });
    return returnValues;
}
exports.decodeLog = decodeLog;
function getAbiByType(jsonInterfaces, type) {
    if (!jsonInterfaces || !type) {
        return null;
    }
    if (!(vitejs_utils_1.isArray(jsonInterfaces) || vitejs_utils_1.isObject(jsonInterfaces))) {
        throw new Error('jsonInterfaces need array or object ');
    }
    if (!vitejs_utils_1.isArray(jsonInterfaces) && vitejs_utils_1.isObject(jsonInterfaces)) {
        if (jsonInterfaces.type === type) {
            return jsonInterfaces;
        }
    }
    return jsonInterfaces.find(function (e) { return e.type === type; }) || null;
}
exports.getAbiByType = getAbiByType;
function getInputs(inputs, methodName) {
    try {
        var func = encodeFunction_1.getFunction(inputs, methodName);
        func && (inputs = func);
    }
    catch (err) {
    }
    if (!vitejs_utils_1.isArray(inputs) && !vitejs_utils_1.isObject(inputs)) {
        throw new Error("[Error] decodeLog: Illegal inputs " + JSON.stringify(inputs) + ". Should be Array or JsonInterface.");
    }
    inputs = vitejs_utils_1.isArray(inputs) ? inputs : inputs.inputs;
    return inputs || [];
}
